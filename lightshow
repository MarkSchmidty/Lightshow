#!/usr/bin/perl
# POD {{{
=head1 NAME

lightshow - Manage color and dimmable LEDs

=head1 SYNOPSIS

	lightshow <command> [options] [@profile]

	lightshow <on|off|dim|dimest|bright|brightest>
	lightshow color <color-number>
	lightshow list
	lightshow <program>

=head1 COMMANDS

=over 8

=item B<on>

Turn all lights on.

=item B<off>

Turn all lights off.

=item B<dim>

Dim all lights by one dim step.

=item B<dimest>

Dim all lights to the lowest setting.

=item B<bright>

Brighten all lights by one dim step.

=item B<dimest>

Birghten all lights to the highest setting.

=item B<color [color-number]>

Set all lights to the color code specified.
The color code must be between 0 and 255 or 'white'.

=item B<list>

List all available macros.

=item B<<program>>

Run a macro program.

You can use 'list' to get a list of available macros.

=item B<version>

Display various version informaiton about the lightshow program.

=back

=head1 OPTIONS

=over 8

=item B<[@profile]>

Specifies which profile to use when addressing Lightshow.

	# Display version information fod the default profile
	
	lightshow version


	# Use profile 'upstairs' specifically

	lightshow version @upstairs

=item B<--dryrun>

=item B<-n>

Dry run mode.
When enabled Lightshow will continue as normal but no actual call to the remote interface is made. This can be useful for debugging when combined with '--verbose'.

=item B<-v>

=item B<--verbose>

Be more verbose when outputting information to STDERR.
Specify multiple times to increase verbosity.

=back

=head1 DESCRIPTION

A command line tool for the manipulation LED lighting systems.

=head1 EXAMPLES

=over

=item B<lightshow on>

Turn on all lights.

=item B<lightshow color 50 @upstairs>

Set all lights under the profile 'upstairs' to color number 50.

=item B<lightshow strobe>

Run the macro program 'strobe' on the default profile.

=back

=head1 FILES

=over 8

=item B</etc/lightshowrc>

System global Lightshow file.

=item B<.vmmrc>

Lightshow config file for the local user.

=back

=head1 CONFIG

The /etc/lightshowrc and .lightshowrc files will be processed to determine Lightshow's configuration, the latter file taking precedence.

The layout of the config file spcifies which profiles to use.

	[GLOBAL]
	profile = Downstairs
	protocol = udp
	syslog = off
	kill = off
	verbose = 0

	[Upstairs]
	address = 10.0.0.101
	port = 50000
	mode = white

	[Downstairs]
	address = 10.0.0.102
	port = 50000
	mode = color

=over 8

=item B<address>

The IP address of the server to use.

=item B<kill>

Attempt to find and kill all other versions of Lightshow before continuing.

=item B<mode>

Which mode to support. Valid options are: color and white

=item B<port>

The port to use on the remote server.

=item B<profile>

Specify the default profile to use if none is explicity stated.

=item B<protocol>

Set the protocol to use. Valid options are: tcp and udp

=item B<verbose>

The amount of verbosity to use.

=item B<syslog>

Also log all output to SysLog.

=back

=head1 INSTALLATION

VMM requires a few external modules before it can work correctly. Follow the following stages to get everything working.

Install all the required CPAN modules:
	
	cpan Config::IniFiles Getopt::Long

=head1 BUGS

Quite probably.

Please report to https://github.com/hash-bang/Lightshow if found.

=head1 AUTHOR

Matt Carter <m@ttcarter.com>

=cut
# }}} POD
# Header {{{
package lightshow;
our $VERSION = '0.1.0';

use Config::IniFiles;
use Getopt::Long;
use File::Basename;
use IO::Handle;
use IO::Socket;
use Sys::Syslog qw/syslog/;
Getopt::Long::Configure('bundling', 'ignorecase_always', 'pass_through');
STDERR->autoflush(1); # } Flush the output DIRECTLY to the output buffer without caching
STDOUT->autoflush(1); # }
# }}}
# Config loading {{{
my $cfgfile;
if (-e "/etc/lightshowrc") {
	$cfgfile = "/etc/lightshowrc";
} elsif (-e "$ENV{HOME}/.lightshowrc") {
	$cfgfile = "$ENV{HOME}/.lightshowrc";
} else {
	fatal("No config file could be found at either /etc/lightshowrc or \$HOME/.lightshowrc");
}

our $verbose = 0;
my $cfg = Config::IniFiles->new(
	-file => ($cfgfile ? $cfgfile : \*DATA), # Read defaults from __DATA__ section if we cant find a default file.
	-default => 'global',
	-fallback => 'global',
	-nocase => 1,
	-allowempty => 1,
	-handle_trailing_comment => 1,
);


my $profile; # The active profile to use
@ARGV = grep { # Scan for '@profile' strings in @ARGV
	if (/^@(.+)$/) {
		fatal("Only one profile may be set per invocation. Profile was originally '$profile' when you tried to override with '$_'") if $profile;
		$profile = $1;
		undef;
	} else {
		$_;
	}
} @ARGV;

$verbose = $cfg->val('global', 'verbose', 0); # Early import from global so 'say' works correctly in the following profile options
if ($profile) { # User wants to select a specific profile
	fatal("Profile not valid: $profile") unless $cfg->exists($profile, 'url');
	say(2, "Using user set profile '$profile'");
} elsif ($cfg->exists('global', 'profile')) { # Default profile option set in config
	$profile = $cfg->val('global', 'profile');
	say(2, "Using config file default profile '$profile'");
} elsif ($cfg->val('global', 'profile')) { # Config file specifies default fallback profile
	$profile = $cfg->val('global', 'profile', $profile);
} else { # Use first section found that isn't 'global'
	$profile = [grep { $_ ne 'global' } $cfg->Sections]->[0];
	say(2, "Using first found profile '$profile'");
}

fatal("No address specified for profile $profile") unless $cfg->exists($profile, 'address');
fatal("No port specified for profile $profile") unless $cfg->exists($profile, 'port');
fatal("No mode specified for profile $profile - must be 'color' or 'white'") unless $cfg->exists($profile, 'mode');
fatal("No protocol specified for profile $profile - must be 'udp' or 'tcp'") unless $cfg->exists($profile, 'protocol');

# Import various options from the config file. These can be overriden in the GetOptions call below.
$verbose = $cfg->val($profile, 'verbose', 0); # Late import which overrides the 'global/verbose' setting now we know what profile to use
our $dryrun = $cfg->val($profile, 'dryrun', 0);
our $mode = $cfg->val($profile, 'mode', 'color');
our $syslog = enabled($cfg->val($profile, 'syslog', 'off'));

# }}} Config loading
# Command line options loading {{{
GetOptions(
	# Global options
	'dryrun|n' => \$dryrun,
	'verbose|v+' => \$verbose,
	'syslog|s' => \$syslog,
);

my $cmd = shift; # Extract what command we should work with
# }}} Command line options loading
# Functions {{{
# Flow control {{{
sub fatal {
	# Print an error message and fatally die
	print STDERR @_, "\n";
	exit 1;
}

sub say {
	# Print a message to STDERR based on the verbosity level
	our $verbose;
	our $syslog;
	my $verbosity = shift;
	if ($verbose >= $verbosity) {
		print STDERR @_, "\n";
		syslog('debug', @_) if $syslog;
	}
}

sub pause {
	# Wait a number of seconds (specified by the -w [seconds]) between VM operations
	# This function purposely ignores the first vm (thus not bothering to wait for the last vm to finish)
	our $wait;
	if ($wait > 0) {
		say(0, "Waiting $wait seconds...");
		sleep($wait);
	}
}

sub enabled {
	# Convert a human string into a bool
	my $_ = shift;
	return m/^y|on|enabled|1/;
}
# }}} Flow control
# Core functions {{{
sub lightdo {
	our $sock;
	my $string = shift;
	$sock->send($string);
	sleep 1; # FIXME: This is stupid
}
# }}}
# Convenience functions {{{
our $lightshow = 1;

sub lightcolor {
	my $color = int(shift);
	if ($color >= 0 && $color <= 255) {
		lightdo("\x20" . chr($color) . "\x55");
	} else {
		say(1, "Invalid color code: must be between 0 and 255") ;
	}
}

sub lighton {
	our $mode;
	lightdo($mode=='color'?"\x22\x00\x55":"\x35\x00\x55");
}

sub lightoff {
	our $mode;
	lightdo($mode=='color'?"\x21\x00\x55":"\x39\x00\x55");
}

sub lightbright {
	our $mode;
	my $direction = shift;
	if ($direction eq 'down') {
		say(3, 'Stepping brightness down');
		lightdo($mode=='color'?"\x24\x00\x55":"\x34\x00\x55");
	} elsif ($direction eq 'up') {
		say(3, 'Stepping brightness up');
		lightdo($mode=='color'?"\x23\x00\x55":"\x3c\x00\x55");
	} elsif ($direction =~ /^dim/) {
		say(3, 'Stepping brightness to lowest');
		for (1..($mode=='color'?9:10)) {
			lightbright('down');
		}
	} elsif ($direction =~ /^bright/) {
		say(3, 'Stepping brightness to highest');
		for (1..($mode=='color'?9:10)) {
			lightbright('up');
		}
	}
}
# }}}
# }}}
# Sock init {{{
system("ps -C lightshow -o pid= | grep -v $$ | xargs -r kill") if enabled($cfg->val($profile, 'kill', 'off'));

say(3, "Connecting to " . $cfg->val($profile, 'address') . ':' . $cfg->val($profile, 'port'));
our $sock = IO::Socket::INET->new(
	Proto => $cfg->val($profile, 'protocol', 0),
	PeerPort => $cfg->val($profile, 'port', 0),
	PeerAddr => $cfg->val($profile, 'address', 0),
) or fatal('Could not open socket');
# }}}
# Commands {{{
if ($cmd eq 'on') {
	lighton();
} elsif ($cmd eq 'off') {
	lightoff();
} elsif ($cmd eq 'color') {
	fatal("Only available in color mode") if ($mode != 'color');
	lightcolor(shift);
} elsif ($cmd eq 'dim') {
	lightbright('down');
} elsif ($cmd eq 'dimest') {
	lightbright('dimest');
} elsif ($cmd eq 'bright') {
	lightbright('up');
} elsif ($cmd eq 'brightest') {
	lightbright('brightest');
} elsif ($cmd eq 'list') {
	for (glob('macros/*.ls')) {
		$_ = basename($_);
		s/\.ls$//;
		say(0, $_);
	}
} elsif ($cmd eq 'config') {
	$cfg->OutputConfig();
} elsif ($cmd eq 'version') {
	say(0, "Lightshow v$VERSION");
} elsif ($cmd eq '') {
	say(0, "Lightshow v$VERSION");
	say(0, "");
	say(0, "Built-in commands:");
	say(0, " * on | off | dim | dimest | bright | brightest");
	say(0, " * color <color-number>");
	say(0, " * list");
	say(0, "Macros:");
	for (glob('macros/*.ls')) {
		$_ = basename($_);
		s/\.ls$//;
		say(0, " * $_");
	}
} elsif ($cmd =~ m/\.ls$/ && -f $cmd) { # Raw pointer to a program?
	say(1, "Running macro: $cmd");
	require $cmd;
} else { # Probably a program
	fatal("Unknown command or program: $cmd") unless -f "macros/$cmd.ls";
	say(1, "Running macro: $cmd");
	require "macros/$cmd.ls";
}
# }}}
